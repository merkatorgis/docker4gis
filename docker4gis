#!/bin/bash

export MSYS_NO_PATHCONV=1
docker4gis=$(basename "$0")
log_path=$docker4gis.log
version_development=development

# Trace/debug log.
if [ "$1" = trace ]; then
    shift 1
    export DOCKER4GIS_TRACE=true
    # Tee all stdout & stderr to a log file (from
    # https://superuser.com/a/212436/462952).
    exec > >(tee "$log_path") 2>&1
    # Trace all shell commands.
    set -x
    export SHELLOPTS
fi

# Set the action variable.
action=$1
shift 1

default_docker4gis_command="npx --yes $docker4gis@latest"
DOCKER4GIS_COMMAND=${DOCKER4GIS_COMMAND:-${ALIAS_NAME:-$default_docker4gis_command}}
export DOCKER4GIS_COMMAND

# Don't use realpath here, to prevent resolving symlinks.
DOCKER4GIS_EXECUTABLE=$0
export DOCKER4GIS_EXECUTABLE

# Set the INSTALLED variable.
INSTALLED=
dg_dir=$(dirname "$0")
if [ "$(basename "$dg_dir")" = '.bin' ]; then
    INSTALLED=true
    dg_dir="$dg_dir"/../$docker4gis
fi
dg_dir=$(realpath "$dg_dir")

# Set the DOCKER_BASE variable (leading to main.sh, amongst others).
DOCKER_BASE="$dg_dir"/base

# Facilitate running npm dependencies.
if if [ "$INSTALLED" ]; then
    node_modules=$dg_dir/..
else
    node_modules=$dg_dir/node_modules
    # Install the git clone if it wasn't already.
    [ -d "$node_modules" ] || (
        cd "$dg_dir" &&
            npm install
    )
fi &&
    node_modules=$(realpath "$node_modules") &&
    [ -d "$node_modules" ] &&
    [ "$(basename "$node_modules")" = node_modules ]; then
    # Export the paths to npm dependencies.
    export BATS=$node_modules/.bin/bats
else
    echo "node_modules directory not found - $node_modules" >&2
    exit 1
fi

export PIPELINE=${PIPELINE:-$TF_BUILD}
export PIPELINE_DOCKER_REPO=${PIPELINE_DOCKER_REPO:-$BUILD_REPOSITORY_NAME}
export PIPELINE_DOCKER_USER=${PIPELINE_DOCKER_USER:-$SYSTEM_TEAMPROJECT}

export DEVOPS_ORGANISATION=${DEVOPS_ORGANISATION:-'merkatordev'}
export DEVOPS_DOCKER_REGISTRY=${DEVOPS_DOCKER_REGISTRY:-"docker.merkator.com"}
export DEVOPS_VPN_POOL=${DEVOPS_VPN_POOL:-'VPN Agent'}

package_json() {
    [ -f package.json ] || echo '{
  "version": "0.0.0"
}' >package.json
    echo '*.log' >>.gitignore
}

pipeline() {
    local main=main

    [ "$action" = init ] && local is_package=true
    [ "$action" = base-component ] && local is_base_component=true

    local docker_login_command="echo '\$(DOCKER_PASSWORD)' | docker login -u=$DOCKER_USER --password-stdin $DOCKER_REGISTRY"

    local steps

    write() {
        # Either $build_validation or $continuous_integration.
        local file=$1

        # write - 1. Initialise variables.

        local trigger=none
        local pr=$main
        local stage=pr_stage
        local stage_display_name='Pull Request stage'
        local job=pr_job
        local job_display_name='Pull Request job'
        local login_steps=""

        [ "$file" = "$continuous_integration" ] && {
            trigger=$main
            pr=none
            stage=ci_stage
            stage_display_name='Continuous Integration stage'
            job=ci_job
            job_display_name='Continuous Integration job'
            if [ "$action" = base-component ]; then
                # We're on GitHub, in a docker4gis base component's repo.
                local git_repo
                git_repo=$(basename "$(realpath .)")
                login_steps="
- bash: |
    git remote set-url origin https://merkatorgis:\$(GITHUB_PASSWORD)@github.com/merkatorgis/$git_repo.git
"
            else
                # We're on Azure DevOps, in a concrete application component's
                # git repo.
                login_steps="
- checkout: self
  persistCredentials: true
"
            fi
            login_steps+="  displayName: Git login
"
        }

        # The build of a Package image verifies that all component images are
        # available at the docker registry, for which it needs to log in. All
        # Continuous Integration pipelines need to log into the docker registry
        # for pushing the resulting new image version.
        if [ "$is_package" ] || [ "$file" = "$continuous_integration" ]; then
            login_steps+="
- bash: |
    $docker_login_command
  displayName: Docker login
"
        fi

        # write - 2. Collect and format the steps.

        # Prepend global steps with login_steps.
        local steps=$login_steps$steps

        # Trim the leading newline.
        steps=${steps#$'\n'}

        # Prepend (local) steps with the correct number of spaces:
        steps=$(echo "$steps" | awk '{print "    " $0}')

        # write - 3. Write the pipeline file, with the formatted steps in a
        # first job of a first stage.

        echo "trigger:
- $trigger

pr:
- $pr

stages:
- stage: $stage
  displayName: $stage_display_name
  jobs:
  - job: $job
    displayName: $job_display_name
    steps:
$steps" >"$file"

        # write - End of function.
    }

    # pipeline - 1. Write the Build Validation pipeline.

    steps="
- bash: |
    $default_docker4gis_command build
  displayName: $docker4gis build"

    # For a package image, also run the application and any integration tests.
    [ "$is_package" ] && steps+="

- bash: |
    echo '' | $default_docker4gis_command run latest
  displayName: Run app and integration tests"

    # Write the file.
    local build_validation=azure-pipeline-build-validation.yml
    write "$build_validation"

    # pipeline - 2. Write the Continuous Integration pipeline.

    # Save the current steps.
    local build_steps=$steps

    steps="
- bash: |
    git config --global user.email 'pipeline@azure.com'
    git config --global user.name 'Azure Pipeline'
  displayName: Git config

- bash: |
    git checkout -b $main
    git push --set-upstream origin $main
  displayName: Git undo detached state
"

    # For a package image, build, run, and test as a validation for the push
    # action.
    [ "$is_package" ] && steps+="$build_steps
"

    # Bump, build, push, tag, and commit the new version.
    steps+="
- bash: |
    $default_docker4gis_command push
  displayName: $docker4gis push"

    # For a non-base-component, set the DOCKER4GIS_VERSION variable for use in
    # the deployment stages.
    [ "$is_base_component" ] || steps+="

- bash: |
    DOCKER4GIS_VERSION=v\$(node --print \"require('./package.json').version\")
    echo \"##vso[task.setvariable variable=DOCKER4GIS_VERSION;isOutput=true]\$DOCKER4GIS_VERSION\"
  displayName: Set DOCKER4GIS_VERSION variable for deploy stage
  name: docker4gis_version_step"

    # Write the file.
    local continuous_integration=azure-pipeline-continuous-integration.yml
    write "$continuous_integration"

    # For a base-component, skip the deployment stages.
    [ "$is_base_component" ] && return

    # Append deployment stages.
    [ "$is_package" ] || {
        local suffix=_SINGLE
        [ -n "$DOCKER4GIS_DEVOPS" ] && echo -n "
# The deployment jobs depend on environments named with a $suffix suffix, which
# are configured with a manual approval check to prevent the jobs from running
# automatically." >>"$continuous_integration"
        echo -n "
# Note that the deployment jobs only run the container of a single component,
# which is a different deployment model than letting the ^package pipeline
# manage which version of each component is to be run." >>"$continuous_integration"
        [ -n "$DOCKER4GIS_DEVOPS" ] && echo -n "
# The ^package model uses the environments without the $suffix suffix, so you
# choose the deployment model to use by removing the manual approval check from
# either the \"plain\" or the $suffix environments." >>"$continuous_integration"
        echo >>"$continuous_integration"
    }
    for environment in TEST PRODUCTION; do
        local temp
        temp=$(mktemp)
        [ "$previous_environment" ] && local extra_dependency="
  - ${previous_environment}_deploy_stage"
        echo "
- stage: ${environment}_deploy_stage
  displayName: Deploy $environment stage
  dependsOn:
  - ci_stage$extra_dependency
  # You probably need to set up a custom pool, with an agent that runs from a
  # location that is whitelisted in your target servers' firewalls. Otherwise,
  # you can comment out the next line.
  pool: $DEVOPS_VPN_POOL
  jobs:
  - deployment: ${environment}_deploy_job
    displayName: Deploy $environment job
    environment: $environment$suffix
    variables:
      DOCKER4GIS_VERSION: \$[ stageDependencies.ci_stage.ci_job.outputs['docker4gis_version_step.DOCKER4GIS_VERSION'] ]
    strategy:
      runOnce:
        deploy:
          steps:
          - task: SSH@0
            inputs:
              sshEndpoint: $environment
              runOptions: inline
              inline: |
                # Log into the Docker registry.
                $docker_login_command 2>&1 || exit

                # Go to the application's directory.
                app_dir=/opt/docker4gis/$DOCKER_USER
                mkdir -p \$app_dir
                cd \$app_dir || exit

                tag=\$(DOCKER4GIS_VERSION)
$(
            if [ "$is_package" ]; then
                export DOCKER_REGISTRY
                export DOCKER_USER
                echo "                echo '' | {"
                # Loop over each line in the output of command $DOCKER_BASE/package/setup_pipeline.sh.
                while IFS= read -r line; do
                    echo "                  $line"
                done < <("$DOCKER_BASE/package/setup_pipeline.sh" "$environment")
                echo "                }"
            else
                echo "                export DOCKER_ENV=$environment"
                if [ "$repo" = proxy ]; then
                    local subdomain=tst
                    [ "$environment" = PRODUCTION ] && subdomain=www
                    echo "                export PROXY_HOST=$subdomain.$DOCKER_USER.com"
                    echo "                # Set to true to get a certificate through LetsEncrypt."
                    echo "                export AUTOCERT=false"
                fi
                local image=$DOCKER_REGISTRY/$DOCKER_USER/$repo:\$tag
                local dcr="docker container run --rm \"$image\""
                dcr+=" /.docker4gis/run \"\$tag\""
                echo "                eval \"\$($dcr)\""
            fi
        )" >"$temp"
        if [ -n "$DOCKER4GIS_DEVOPS" ]; then
            # We're running from the dg devops command, so the Environments, and
            # their Manual Approval checks are set up as well, preventing the
            # deployment stages from running automatically, so we don't have to
            # comment-out their definiion.
            cat "$temp" >>"$continuous_integration"
        else
            [ "$previous_environment" ] || echo "
# Uncomment the deploy stages to have the pipeline deploy automatically to the
# corresponding environment. This depends on the docker4gis_version_step in the
# ci_stage, AND on a Service Connection (of type \"SSH\") (see the
# \"sshEndpoint\" attribute) configured in the Project for each environment." >>"$continuous_integration"
            # Loop over each line in "$temp" and append it, commented-out, to
            # "$continuous_integration".
            while IFS= read -r line; do
                echo "# $line" >>"$continuous_integration"
            done <"$temp"
        fi
        rm "$temp"
        previous_environment=$environment
    done

    # pipeline - End of function.
}

version() {
    local local=$1
    if [ "$local" = local ]; then
        dotenv &&
            echo "$DOCKER4GIS_VERSION"
    else
        if [ "$INSTALLED" ] || [ "$DOCKER4GIS_DEVOPS" ]; then
            node --print "require('$DOCKER_BASE/../package.json').version"
        else
            echo "$version_development"
        fi
    fi
}

# shellcheck disable=SC1091
source "$DOCKER_BASE"/dotenv.bash

assert_docker4gis_directory() {
    dotenv
}

# shellcheck disable=SC2317  # It's correct that the function is never called in this script.
self() {
    # Command given to the "all" action may use `self` to run docker4gis actions.
    "$0" "$@"
}

just_help=
[ "$1" = help ] && just_help=true
[ "$action" = help ] && {
    just_help=true
    action=$1
    shift 1
}
help() {
    [ "$just_help" ] || return 0
    local help_text=$1
    echo "$help_text" | less --quit-if-one-screen
    exit
}
just_help() {
    just_help=true
    help "$@"
}

remote_branch_name_available() {
    local new_branch=$1
    remote_branch_info=$(git ls-remote --heads origin refs/heads/"$new_branch") &&
        if [ "$remote_branch_info" ]; then
            echo "Error: remote branch exists: $new_branch" >&2
            false
        fi
}

rename_replace() {
    local old_value=$1
    local new_value=$2

    find_no_git() {
        # Use -prune to to exclude any `.git` directory;
        # https://stackoverflow.com/a/4210072/2389922.
        dir=$1
        shift 1
        find "$dir" -type d -name .git -prune -false -o "$@"
    }

    # 1. Replace text in files.
    find_no_git . -type f \
        -exec sed -i "s|$old_value|$new_value|g" {} \;

    # 2. Rename files and directories. See
    # https://www.shellcheck.net/wiki/SC2044 for the loop over `find`.
    while IFS= read -r -d '' file; do
        file=$(realpath "$file")
        mv "$file" "$(dirname "$file")/$new_value"
    done < <(find_no_git . -name "$old_value" -print0)
}

case "$action" in

init)
    help "Initialise a new $docker4gis application in the current directory.
Do this in a directory where you can later create sibbling directories for the
application's components (using \`$DOCKER4GIS_COMMAND component\`). The name of
the components'parent directory will be used as the application name."

    DOCKER_REGISTRY=$1
    DOCKER_USER=$(basename "$(realpath ..)")

    [ "$DOCKER_REGISTRY" ] && shift 1
    [ "$DOCKER_REGISTRY" ] || read -rp \
        "Enter the Docker registry (default is the Docker Hub; enter m for docker.merkator.com) : " \
        DOCKER_REGISTRY
    [ "$DOCKER_REGISTRY" = 'm' ] && DOCKER_REGISTRY=docker.merkator.com
    [ "$DOCKER_REGISTRY" ] || DOCKER_REGISTRY=docker.io

    echo "DOCKER4GIS_VERSION=$(version)
DOCKER_REGISTRY=$DOCKER_REGISTRY
DOCKER_REPO=package
DEBUG=false
PROXY_HOST=
PROXY_PORT=
PROXY_PORT_HTTP=
API=
AUTH_PATH=
APP=
HOMEDEST=
TZ=
PGHOST=
PGHOSTADDR=
PGPORT=
PGDATABASE=
PGUSER=
PGPASSWORD=
POSTGRES_LOG_STATEMENT=
# POSTGRES_LOG_STATEMENT=ddl
# POSTGRES_LOG_STATEMENT=all
MYSQL_HOST=
MYSQL_DATABASE=
MYSQL_ROOT_PASSWORD=
POSTFIX_DESTINATION=
POSTFIX_DOMAIN=" >>.env

    mkdir -p components

    package_json
    pipeline

    # Offer to create the dg alias.
    if [ -z "$DOCKER4GIS_DEVOPS" ] && [ -z "$ALIAS_NAME" ]; then
        bash -i "$0" alias TEST
    fi
    ;;

component | base-component | template)
    [ "$action" = component ] && help "Initialise a new $docker4gis application component in the current directory.
Do this in a sibling directory of your application directory (where you ran
\`$DOCKER4GIS_COMMAND init\`)."

    [ "$action" = base-component ] && help "Initialise a new $docker4gis base component in the current directory.
Base components are the repositories in https://hub.docker.com/u/$docker4gis.
This action will render a skeleton that you can build upon. Get in touch with
to discuss publication."

    [ "$action" = template ] && help "When developing a $docker4gis base component, scaffold a client application in
the current directory, so that you can try your new base component. When you're
happy, you can copy the contents into the 'template' directory of your base
component."

    write_dotenv() {
        local docker_user=$1
        echo "DOCKER4GIS_VERSION=$DOCKER4GIS_VERSION
DOCKER_REGISTRY=$DOCKER_REGISTRY" >>.env
        [ "$docker_user" ] && echo "DOCKER_USER=$DOCKER_USER" >>.env
    }

    replace_component() {
        search='{{COMPONENT}}'
        replace=$repo
        find . -type f -exec sed -i "s|$search|$replace|ig" {} \;
    }

    finish() {
        local message=${1:-"$action initialised ✅"}
        local code=${2:-0}
        echo "$message"
        exit "$code"
    }

    error() {
        local message=${1:-error}
        local code=${2:-1}
        finish "$message" "$code"
    }

    package_json

    repo=$(basename "$(realpath "$PWD")")
    # Without a possible `docker4gis-` prefix.
    repo=${repo#"$docker4gis"-}
    # Up until a possible first `.` character (to support forked repos named
    # component.name.surname).
    repo=${repo%%.*}
    export repo

    [ "$action" = base-component ] && {
        # Creating a generic docker4gis base component.
        DOCKER4GIS_VERSION=$(version)
        DOCKER_REGISTRY=docker.io
        DOCKER_USER=$docker4gis

        cp -r "$DOCKER_BASE"/template/. .
        echo "
# Set environment variables.
ONBUILD ARG DOCKER_REGISTRY
ONBUILD ENV DOCKER_REGISTRY=\$DOCKER_REGISTRY
ONBUILD ARG DOCKER_USER
ONBUILD ENV DOCKER_USER=\$DOCKER_USER
ONBUILD ARG DOCKER_REPO
ONBUILD ENV DOCKER_REPO=\$DOCKER_REPO

# Make this an extensible base component; see
# https://github.com/merkatorgis/docker4gis/tree/npm-package/docs#extending-base-components.
ONBUILD COPY conf/args /.docker4gis/
COPY template /template/
" >>Dockerfile
        replace_component

        write_dotenv "$DOCKER_USER"
        pipeline
        # And we're done!
        finish
    }

    # Creating a concrete application's component.

    # Test if inited by finding package directory.
    for env_file in ../*/.env; do
        # Break when there's none.
        [ -f "$env_file" ] || break
        DOCKER_REPO=
        DOCKER4GIS_VERSION=
        DOCKER_REGISTRY=
        DOCKER_USER=
        dotenv forgiving "$env_file"
        if [ "$DOCKER_REPO" = package ] && [ "$DOCKER4GIS_VERSION" ] && [ "$DOCKER_REGISTRY" ] && [ "$DOCKER_USER" ]; then
            inited=true
            break
        fi
    done

    [ "$inited" ] ||
        error "Package directory not foud; to create one, run $DOCKER4GIS_COMMAND init. Or did
you mean base-component?"

    write_dotenv

    pull() {
        local component=$1
        local stderr=$2

        image=$docker4gis/$component:latest

        local cmd="docker image pull $image"
        if [ "$stderr" = stderr ]; then
            $cmd
        else
            $cmd 2>/dev/null
        fi
    }

    [ "$1" ] || interactive=true
    component=$1
    template=$2

    if ! [ "$component" ]; then
        [ "$repo" = api ] && suggestion=postgrest
        [ "$repo" = app ] && suggestion=angular
    fi
    if ! [ "$suggestion" ]; then
        pull "${component:-$repo}" && component=${component:-$repo}
    fi
    while ! [ "$component" ]; do
        if [ "$suggestion" ] || ! [ "$action" = template ]; then
            hints=true
        fi
        component_question="Which $docker4gis base image to extend? e.g. proxy, or postgis"
        [ "$hints" ] && component_question+=' ('
        [ "$suggestion" ] && component_question+="default is $suggestion"
        [ "$suggestion" ] && [ "$action" != template ] && component_question+=", "
        [ "$action" = template ] || component_question+="n for none"
        [ "$hints" ] && component_question+=')'

        read -rp \
            "$component_question : " \
            component
        [ "$component" ] || component=$suggestion
        [ "$component" = n ] && [ "$action" != template ] && break
        pull "$component" stderr || component=
    done

    [ "$action" = template ] && {
        # Just scaffolding an inital setup for developing a template for a new
        # base component.
        cp -r "$DOCKER_BASE"/template/template/. .
    }

    [ "$component" = n ] && {
        # Creating a component _not_ extending a docker4gis base component.
        cp -r "$DOCKER_BASE"/template/. .
        rm -rf template
        echo "
# Set environment variables.
ARG DOCKER_REGISTRY
ENV DOCKER_REGISTRY=\$DOCKER_REGISTRY
ARG DOCKER_USER
ENV DOCKER_USER=\$DOCKER_USER
ARG DOCKER_REPO
ENV DOCKER_REPO=\$DOCKER_REPO
" >>Dockerfile
        pipeline
    }

    [ "$action" = template ] || [ "$component" = n ] && {
        replace_component
        # And we're done!
        finish
    }

    # Creating a component extending a docker4gis base component.

    pipeline

    container=$(docker container create "$image") ||
        error "Failed to create container from image $image"

    docker container cp "$container":/template . ||
        error "$image doesn't seem a $docker4gis component"

    docker container rm "$container" >/dev/null
    if ! [ "$template" ]; then
        # Test if there are multiple templates, by checking the existence of the
        # '.default' file.
        default=./template/.default
        if [ -f "$default" ]; then
            default=$(cat "$default")
            # Override the default template if there's a template named just
            # like the repo itself.
            [ -d "./template/$repo" ] && default=$repo
            template=$default
            [ "$interactive" ] && {
                choices=$(ls ./template)
                choices=$(echo "$choices" | xargs)
                read -rp \
                    "Enter the template name (one of: $choices - default is $default) : " \
                    template
                [ "$template" ] || template=$default
                ls ./template/"$template" >/dev/null 2>&1 ||
                    error "Template not found: $template"
            }
        fi
    fi
    cp -r ./template/"$template"/. .
    rm -rf ./template
    rename_replace '{{DOCKER_USER}}' "$DOCKER_USER"
    finish
    ;;

build | b | run | r | br | push | p | test | t | unbuild | stop | geoserver)
    [ "$action" = build ] || [ "$action" = b ] && help "Build a new image for the application component in the current directory.
Or pass the name of a sibling directory to build that component there.

For components other than the 'package' component, any/all (unit) tests are run
before the build starts, and the build is cancelled if any test fails (see
\`$DOCKER4GIS_COMMAND help test\`.)"

    [ "$action" = run ] || [ "$action" = r ] && help "Run the application.

If a newer version of a component is found in a sibling component directory, the
'package' component's directory is updated to run that newer version.
If a 'latest' version of a component image is found locally, and the version
in the component's package.json isn't newer than the version that is registered
in the 'package' directory, then that 'latest' component version
is run.

After all components' containers are started, any/all (integration) tests are
run (see \`$DOCKER4GIS_COMMAND help test\`.)"

    [ "$action" = br ] && help "First build, then run.
Can also \`$DOCKER4GIS_COMMAND $action [COMPONENT] [ARG...]\` from a sibling directory."

    [ "$action" = push ] || [ "$action" = p ] && help "Increment the component's version, build its image, push it to the Docker
registry, commit and push git changes.

Note that ideally, this is run by the Continuous Integration pipeline. If
that's configured, refrain from running \`$DOCKER4GIS_COMMAND $action\` by hand.

Pass --no-save as the first argument to prevent the component's version from
being bumped and saved in git, which is useful when you create different
'flavours' of the image with each version. --no-save also prevents the image
being additionally tagged as 'latest'.
Use --no-save in all but the last \`$action\` step in a pipeline."

    [ "$action" = test ] || [ "$action" = t ] && help "Run the component's tests.
First, any files named 'test.sh' in the component's directory (and below) are
run. Exit from a test.sh with a non-zero code to indicate failure. Call the
exported function abort_tests to prevent running any further tests.

Then, any files named '*.bats' in the component's directory (and below) are run
using the [bash automated testing system](https://www.npmjs.com/package/bats).

If run with the optional FILE parameter, only the tests in that file are run. It
should be a .bats file, or an executable .sh file.

On \`$DOCKER4GIS_COMMAND build\`, all tests (considered to be 'unit tests') are
run before starting the build. If any test fails, the build is cancelled.
This is true for pipelines as well. Should a test depend on any external
package, amend the pipelines to install it, or include it as an [npm]
(https://www.npmjs.com/) dependency.

An exception is the 'package' component. Here, test are considered 'integration
tests', and they're not run before the \`$DOCKER4GIS_COMMAND build\`, but after
the \`$DOCKER4GIS_COMMAND run\`. So when these tests run, all the components'
containers have been started, and you can verify their interacting together.
Note that \`$DOCKER4GIS_COMMAND run\` is only done in the development
environment; not on any server where the application is deployed (though it can
be imagined as part of some future test-deploy pipeline)."

    [ "$action" = unbuild ] && help "Remove the local 'latest' version of the component's image.
Can also \`$DOCKER4GIS_COMMAND $action [COMPONENT]\` from a sibling directory."

    [ "$action" = stop ] && help "Stop the application's containers.
Except the proxy container, since that may still serve other applications."

    [ "$action" = geoserver ] && help "Copy the GeoServer configuration files out of the running $DOCKER_USER-geoserver
container, to the geoserver component repository in the current directory."

    # For application components, load the package component's environment
    # values. For base components (build), there's no package component, and
    # nothing happens here.
    for env_file in ../*/.env; do
        # Break when there's none.
        [ -f "$env_file" ] || break
        dotenv forgiving "$env_file"
        if [ "$DOCKER_REPO" = package ]; then
            dotenv export "$env_file"
            break
        fi
    done

    # Load the current component's own environment variables.
    dotenv export

    # If not running an unpublished, local, in-development version of
    # docker4gis, switch to the version that the component scripts are
    # expecting.
    if [ "$INSTALLED" ]; then
        if [ "$DOCKER4GIS_VERSION" != "$(version)" ]; then
            [ "$DOCKER4GIS_TRACE" ] && echo "-- Switching to DOCKER4GIS_VERSION $DOCKER4GIS_VERSION."
            DOCKER_BASE=$( (
                # Prevent any trace output.
                set +x
                # Output this version's base directory.
                npx --yes "$docker4gis"@"$DOCKER4GIS_VERSION" base
            ))
        fi
    else
        # Otherwise, ignore the component's current DOCKER4GIS_VERSION, and use
        # the new in-development version to see its effects.
        export DOCKER4GIS_VERSION=$version_development
    fi

    [ "$action" = b ] && action=build
    [ "$action" = r ] && action=run
    [ "$action" = p ] && action=push
    [ "$action" = t ] && action='test'

    "$DOCKER_BASE/main.sh" . "$action" "$@"
    ;;

run-single | rs)
    help "Run a single container.
Usage: $DOCKER4GIS_COMMAND $action [DOCKER_TAG] [DOCKER_REPO] [DOCKER_USER] [DOCKER_REGISTRY]"

    dotenv forgiving
    export DOCKER_TAG=${1:-$DOCKER_TAG}
    export DOCKER_REPO=${2:-$DOCKER_REPO}
    export DOCKER_USER=${3:-$DOCKER_USER}
    export DOCKER_REGISTRY=${4:-$DOCKER_REGISTRY}
    eval "$("$DOCKER_BASE"/.docker4gis/run)"
    ;;

"$docker4gis")
    help "Just echo '$docker4gis' to indicate that this is that program."

    echo "$docker4gis"
    ;;

base)
    help "Echo the value of the DOCKER_BASE variable."

    echo "$DOCKER_BASE"
    ;;

version | v)
    help "Echo the $docker4gis version.
\`$DOCKER4GIS_COMMAND $action\` gives the version of that $docker4gis command
itself.
\`$DOCKER4GIS_COMMAND $action local\` gives the value of the
\$DOCKER4GIS_VERSION variable in the current $docker4gis component directory."

    version "$@"
    ;;

login)
    dotenv forgiving && {
        DOCKER_REGISTRY=" ($DOCKER_REGISTRY)"
        DOCKER_USER=" ($DOCKER_USER)"
    }
    help "Log into the DOCKER_REGISTRY$DOCKER_REGISTRY.
Usage: $DOCKER4GIS_COMMAND $action [PASSWORD] [USER].
Without PASSWORD, you'll be asked to type it.
Default USER is the DOCKER_USER value$DOCKER_USER."

    dotenv
    password=${1:?"password parameter not set"}
    user=${2:-$DOCKER_USER}
    echo "$password" | docker login -u "$user" --password-stdin "$DOCKER_REGISTRY"
    ;;

alias)
    help "Create a shell alias for \`$default_docker4gis_command\`.
Usage: $DOCKER4GIS_COMMAND $action [NAME]
Without NAME, you'll be asked to type one, or accept the default."

    # https://serverfault.com/a/146747
    [[ $- == *i* ]] && interactive=true
    [ "$interactive" ] || {
        # Rerun this action with bash in interactive mode, so that aliases are
        # loaded and recognised by the `type` command.
        exec bash -i "$0" alias "$@"
    }

    dg=dg

    test=$1
    [ "$test" = 'TEST' ] && {
        answer=
        read -rp "Create an alias for \`$default_docker4gis_command\`? [Yn] " answer
        [ "$answer" ] || answer=y
        if ! [ "$answer" = 'y' ] && ! [ "$answer" = 'Y' ]; then
            exit 0
        fi
    }

    name=$1

    [ "$name" ] || read -rp "Enter the name for the alias (default is $dg) : " name
    [ "$name" ] || name=$dg

    type -t "$name" &>/dev/null && {
        echo "$name is occupied; choose another name"
        "$0" alias
        exit
    }

    # Add the alias to the .bashrc file.
    echo "alias $name='ALIAS_NAME=$name $default_docker4gis_command'" >>~/.bashrc

    # Start a new shell, to load the new alias.
    exec bash
    ;;

git-push | gp)
    default_new_branch=$docker4gis-changes
    help "Commit and push all changes to a remote branch.
Usage: $DOCKER4GIS_COMMAND $action [BRANCH_NAME].
The default BRANCH_NAME is $default_new_branch.
If more than one parameter is supplied, all parameters are joined with hyphens
(-) to form the BRANCH_NAME.
All changes are committed in git in a new branch, that is pushed to \`origin\`,
ready to create a pull request. Locally, the new branch is deleted after
switching back to the current branch, ready for fetching the remote changes
after merging the pull request (and running the Continuous Integration
pipeline, and syncing a forked repo)."

    [ "$(git status --short)" ] || {
        echo "No changes to commit."
        exit
    }
    new_branch=${*:-"$default_new_branch"}
    # Replace all spaces with hyphens.
    new_branch=${new_branch// /-}
    remote_branch_name_available "$new_branch" &&
        current_branch=$(git rev-parse --abbrev-ref HEAD) &&
        if [ "$current_branch" != "$new_branch" ]; then
            # This will fail if a branch with that name already exists.
            # Which is good, since it'd be acceptable when we're already
            # _on_ the new_branch, but not when we're on another branch and
            # the new_branch is just existing.
            git switch --create "$new_branch"
        fi &&
        git add --all &&
        git commit --message="$new_branch" &&
        git push --set-upstream origin "$new_branch" &&
        git switch "$current_branch" &&
        git branch --delete "$new_branch" &&
        echo "-> Remote branch $new_branch ready for pull request; the local branch is deleted."
    ;;

bump)
    help "In the current directory's component, bump $docker4gis to the latest version ($(version)).
Usage: $DOCKER4GIS_COMMAND $action [push|gp].
With \`push\` (or \`gp\`), the change is committed in git in a new branch, that 
is pushed to \`origin\`, ready to create a pull request. Locally, the new branch
is deleted after switching back to the current branch, ready for fetching the
remote changes after merging the pull request (and running the Continuous
Integration pipeline, and syncing a forked repo)."

    assert_docker4gis_directory

    if [ "$1" = push ] || [ "$1" = gp ]; then
        bump_branch=$docker4gis-bump
        "$DOCKER_BASE"/check_git_clear.sh &&
            remote_branch_name_available "$bump_branch"
    fi &&
        # The actual bump action.
        echo "DOCKER4GIS_VERSION=$(version)" >>.env &&
        version &&
        if [ "$bump_branch" ]; then
            self git-push "$bump_branch"
        fi
    ;;

standalone)
    help "Don't start the current directory's component when running the application.
Usage: $DOCKER4GIS_COMMAND $action.
Normally, components are expected to be a \"server\" of some sort, and running
the application comes down to starting a container, with the --detach option,
for each component.
A standalone component is excluded from the list of server containers to start,
while you still manage the code and the image for the component in the current
project. For instance, you might want a component that runs a specific data
processing task, maybe as a one-off instance somewhere \"in the cloud\"."

    assert_docker4gis_directory

    [ -z "$1" ] || {
        echo "No parameters expected."
        exit 1
    }

    echo "DOCKER4GIS_STANDALONE=true" >>.env

    component_file=../$DOCKER_USER/components/$DOCKER_REPO
    [ -f "$component_file" ] && rm "$component_file"

    echo "Component $DOCKER_REPO marked as standalone."
    ;;

all)
    help "Run something in each sibling $docker4gis directory.
Usage: $DOCKER4GIS_COMMAND $action EXECUTABLE [ARG...]
If \`$DOCKER4GIS_COMMAND\` should be executed, use \`self\` instead, e.g.
\`$DOCKER4GIS_COMMAND $action self bump push\`"

    # Run the given command in all sibling docker4gis component directories,
    # including the current one.
    for dir in ../*; do
        # Test if this is a docker4gis component directory.
        if (
            cd "$dir" || exit
            dotenv forgiving || exit
            echo
            realpath .
        ); then
            # Now run the given command in that docker4gis component directory.
            (
                cd "$dir" || exit
                "$@"
            ) || error=true
            # Record that we ran the command for at least one docker4gis
            # component (note that we couldn't do this assignment from inside a
            # subshell, which is why we have two steps for "check" and "run").
            any=true
        fi
    done
    # Reflect that we ran something, and that every run was successful.
    [ "$any" ] && ! [ "$error" ]
    ;;

bats)
    default_file=./test.bats
    help "Create a new file in the current directory, that calls the generic bats helper
($DOCKER_BASE/.plugins/bats/helper.bash).
Usage: $DOCKER4GIS_COMMAND $action [FILE]
The deault FILE is $default_file."

    file=${1:-$default_file}
    if [ -e "$file" ]; then
        echo "$file already exists."
        exit 1
    fi
    echo "load ~/.bats/helper.bash

function setup_file() {
    helper
}

" >"$file"
    ;;

devops)
    help "Provision a $docker4gis setup in a Azure DevOps project.

Usage:
- $DOCKER4GIS_COMMAND $action [components|c] [--project|-p PROJECT] [COMPONENT[=REPOSITORY]...]
- $DOCKER4GIS_COMMAND $action set|s pat|t|registry|r|organisation|o|pool|p VALUE

=> You need a Personal Access Token (PAT) of a user that has the right to create
Projects in Azure DevOps (or, for an existing project, of a user that is a
Project Administrator). Create a PAT with scope \"full access\". See for
instructions:
https://learn.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?toc=%2Fazure%2Fdevops%2Forganizations%2Ftoc.json&view=azure-devops&tabs=Windows

The \"components\" action (which is the default) creates a new Project in Azure 
DevOps, with several Repositories (the \"^package\", the \"proxy\", and
components additionally specified), each with a Branch Policy set on the \"main\"
branch, and each with a Build Validation Pipeline (which runs automatically on
each new or modified Pull Request, and wich has to succeed before the PR can be
completed), and a Continuous Integration Pipeline, which runs automatically on
each PR merge/completion. Each \"main\" branch won't allow direct commits, only
PR merges.

=> Edit the generated \"docker4gis\" Variable Group (Pipelines | Library |
docker4gis) to set the proper value for the DOCKER_PASSWORD variable, which is
needed for Pipelines to pull and push images from/to your Docker Registry.

Additionally, a \"TEST\" and \"PRODUCTION\" Environment are created, each with a
template SSH Service Connection. Both Environments require manual Approval by a
project Team member, so the respective Deployment Stages of the ^package's
Continuous Integration Pipeline aren't run automatically. Edit the Service
Connection details (Project settings | Pipelines | Service connections), before
removing the TEST Environment Approval Check (Pipelines | Environments |
TEST/PRODUCTION | Approvals and checks | {hover} | ⁝ | Delete).

The \"components\" action will ask you to type in the Project name (or accept a
default value), unless you specify it through the --project|-p option.

A Repository (and its Policies and Pipelines) is created for each component you
list (plus \"^package\" and \"proxy\"). For an existing Project, existing
Repositories are left untouched, and newly listed ones are added.

A simple name results in a Repository with that name, initialised as an
extension of the $docker4gis base component with the same name. List a
component=repository pair to get a Repository name that is different from the
base component name; e.g. \"angular=app\", or \"postgrest=api\".

The \"set\" action saves the value of a variable to the local file
\`~/$docker4gis-$action.env\`. If any of the variables is not set, the
\"components\" action asks you to type it in the first time.
- pat|p: Personal Access Token
- registry|r: Docker Registry, default: $DEVOPS_DOCKER_REGISTRY
- organisation|o: Organisation, default: $DEVOPS_ORGANISATION
- pool|p: the Agent Pool name that is used in Deployment Pipeline Tasks,
  default: $DEVOPS_VPN_POOL
"
    "$DOCKER_BASE/../$action/run.sh" "$@"
    ;;

*)
    echo "Manage $docker4gis applications and their components and base components.
Usage: $DOCKER4GIS_COMMAND init | component | build|b [COMPONENT] [ARG...] |
  run|r | br [COMPONENT] [ARG...] | push|p [COMPONENT] [--no-save] [ARG...] |
  test|t [FILE] | unbuild [COMPONENT] | stop | geoserver | base-component |
  template | alias [NAME] | $docker4gis | base | login [PASSWORD] [USER] |
  version|v [local] | bump [push] | standalone | git-push|gp [BRANCH_NAME...] |
  run-single|rs [DOCKER_TAG] [DOCKER_REPO] [DOCKER_USER] [DOCKER_REGISTRY] |
  bats | all EXECUTABLE|self [ARG...] |
  devops [components|c] [--project|-p PROJECT] [COMPONENT[=REPOSITORY]...] |
  devops set|s pat|t|registry|r|organisation|o|pool|p VALUE
Note that build, run, br, push, test, stop, unbuild, and geoserver run with the
  $docker4gis version of DOCKER4GIS_VERSION from the current directory's .env.
For help: $DOCKER4GIS_COMMAND COMMAND help, or $DOCKER4GIS_COMMAND help COMMAND.
For debugging (tracing all shell commands):
  $DOCKER4GIS_COMMAND trace COMMAND [ARG...]
  output is saved in $log_path."
    ;;
esac
